"""Database test utilities.
中文注释解释“真连”测试如何初始化数据。
"""
from __future__ import annotations

from datetime import datetime, timedelta, timezone
import random
import string

import pymysql

from backend.config import load_config
from backend.db import init_db_from_schema, get_cursor
from seed_example_data import (
    seed_users,
    seed_organizations,
    seed_event_types,
    seed_events_and_sessions,
)


def reset_and_seed() -> None:
    """重新建表并插入基础示例数据。"""
    init_db_from_schema()
    seed_users()
    seed_organizations()
    seed_event_types()
    seed_events_and_sessions()


def insert_users(total: int) -> list[int]:
    """批量插入指定数量的用户，生成唯一 email，返回 user_id 列表。"""
    sql = """
    INSERT INTO `USER` (name, email, password, role, blocked_until)
    VALUES (%(name)s, %(email)s, %(password)s, %(role)s, %(blocked_until)s)
    ON DUPLICATE KEY UPDATE
        name = VALUES(name),
        password = VALUES(password),
        role = VALUES(role),
        blocked_until = VALUES(blocked_until)
    """
    user_ids: list[int] = []
    with get_cursor() as cursor:
        for i in range(total):
            email = f"bulk_user_{i}@example.com"
            cursor.execute(
                sql,
                {
                    "name": f"BulkUser{i}",
                    "email": email,
                    "password": "password",
                    "role": "visitor",
                    "blocked_until": None,
                },
            )
            # 重新获取 user_id，兼容 ON DUPLICATE 场景
            cursor.execute(
                "SELECT user_id FROM `USER` WHERE email = %s", (email,)
            )
            row = cursor.fetchone()
            if row:
                user_ids.append(int(row["user_id"]))
    return user_ids


def create_event_with_session(*, capacity: int, waiting: int | None = None) -> dict:
    """创建一个独立的 Event + Session，便于测试注册与并发。"""
    now = datetime.now(timezone.utc)
    title_suffix = "".join(random.choices(string.ascii_letters, k=6))
    event = {
        "org_id": None,
        "type_id": 1,
        "title": f"LoadTest-{title_suffix}",
        "description": "autogenerated for tests",
        "location": "Test Hall",
        "status": "published",
        "created_at": now,
        "updated_at": now,
    }
    with get_cursor() as cursor:
        cursor.execute(
            """
            INSERT INTO EVENT (org_id, type_id, title, description, location, status, created_at, updated_at)
            VALUES (%(org_id)s, %(type_id)s, %(title)s, %(description)s, %(location)s, %(status)s, %(created_at)s, %(updated_at)s)
            """,
            event,
        )
        eid = cursor.lastrowid
        cursor.execute(
            """
            INSERT INTO EVENT_SESSION (eid, start_time, end_time, capacity, current_registered, waiting_list_limit, status)
            VALUES (%s, %s, %s, %s, %s, %s, %s)
            """,
            (
                eid,
                now + timedelta(days=1),
                now + timedelta(days=1, hours=2),
                capacity,
                0,
                waiting,
                "open",
            ),
        )
        session_id = cursor.lastrowid
    return {"eid": eid, "session_id": session_id}


def check_db_connection() -> None:
    """如果无法连接数据库则抛出异常，便于在测试中 skip。"""
    cfg = load_config()
    conn = None
    try:
        conn = pymysql.connect(
            host=cfg.DB_HOST,
            port=cfg.DB_PORT,
            user=cfg.DB_USER,
            password=cfg.DB_PASSWORD,
            database=cfg.DB_NAME,
            charset=cfg.DB_CHARSET,
        )
    finally:
        if conn is not None:
            conn.close()
